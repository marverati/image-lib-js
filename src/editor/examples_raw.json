{
  "randomNoise": "gen((x, y) => Math.random() * 255, 1024, 1024);",
  "checkerBoard": "const sz = 32;\ngen((x, y) => (Math.floor(x / sz) % 2) === (Math.floor(y / sz) % 2) ? 255 : 0, 1024, 1024)",
  "spiral": "const branches = param.number('branches', 3, 1, 20);\nconst disFactor = param.number('distance factor', 0.3, 0, 1, 0.001) ** 2;\ngen((x, y) => {\n    const dx = x - width / 2, dy = y - height / 2;\n    const angle = Math.atan2(dx, dy);\n    const distance = Math.sqrt(dx * dx + dy * dy);\n    return 127.5 + 127.5 * Math.sin(branches * angle + disFactor * distance);\n}, 1024, 1024);\n//> Generates a spiral\n//> Use parameters on the right to adjust its look",
  "boxes": "const boxes = [];\nfor (let i = 0; i < 50; i++) {\n    boxes[i] = {x: Math.random() * 1000, y: Math.random() * 1000, w: 100, h: 100}\n}\ngen((x, y) => {\n    const count = boxes.filter(box => x >= box.x && y >= box.y && x < box.x + box.w && y < box.y + box.h).length;\n    return [0, 255, 160, 80][count % 4];\n}, 1024, 1024)",
  "contextDrawing": "resize(1024, 1024);\n// You can affect the output canvas directly\ncontext.fillStyle = 'red';\ncontext.fillRect(0, 0, 1024, 1024);\ncontext.fillStyle = 'blue';\ncontext.fillRect(100, 100, 200, 200);\ncontext.fillStyle = \"black\";\ncontext.font = \"48px Arial\";\ncontext.fillText(\"Hello world\", 400, 400);\n\n// Regular image-lib-js API is still working\ncopyTo(1);\n\n// Or use copy(<canvas>, <id>) to copy from a canvas into a slot / source / target\ncopy(canvas, 2);\n\n// You can create your own \"offscreen\" canvas:\nconst myCanvas = createCanvas(); // if no size is provided, last used size is reused\nconst myContext = myCanvas.getContext('2d');\nmyContext.rotate(Math.PI / 8);\nmyContext.shadowColor = 'gold';\nmyContext.shadowBlur = 20;\nmyContext.fillStyle = 'green';\nmyContext.fillRect(200, 100, 600, 350);\ncopy(myCanvas, 3); // copy to slot 3\nuse(3);\nfilter(c => [c[1], c[0], c[2], c[3]]); // flip channels\n\n// Use fancy features such as blend modes\ncontext.globalCompositeOperation = 'screen';\ncontext.drawImage(myCanvas, 150, 0);",
  "juliaFractal": "const size = param.isLiveUpdate ? 400 : 1024; // <- we do this to ensure that while dragging parameters, we get quick updates, but when releasing slider, we get a higher resolution image\nconst re = param.slider('re', -0.4, -1, 1, 0.01, true);\nconst im = param.slider('im', 0.6, -1, 1, 0.01, true);\nconst iterations = param.number('Iterations (slow)', 256, 1, 1000);\ngen((x0, y0) => {\n    // Map pixel space to [-2, 2]x[-2, 2] space\n    let x = -2 + 4 * x0 / width, y = -2 + 4 * y0 / width + 2 * (width - height) / width;\n    for (let i = 0; i < iterations; i++) {\n        // Return when iteration diverges far enough from origin\n        if (x * x + y * y > 4) {\n            return 255 * Math.sqrt(i / iterations);\n        }\n        // Compute next step\n        const newx = x * x - y * y + re;\n        y = 2 * x * y + im;\n        x = newx;\n    }\n    return 0;\n}, size, size)",
  "juliaInteractive": "let size = 512; // <- we do this to ensure that while dragging parameters, we get quick updates, but when releasing slider, we get a higher resolution image\nlet re = -0.4;\nlet im = 0.6;\nconst iterations = 512;\nsetFrameHandler(({mouse}) => {\n    if (mouse.left !== 0) {\n        if (mouse.left > 0) {\n            // Map mouse position to [-2, 2]x[-2, 2] space\n            re = -2 + 4 * mouse.x / width;\n            im = -2 + 4 * mouse.y / width + 2 * (width - height) / width;\n            size = 400; // live update\n        } else {\n            size = 1024; // release mouse -> higher resolution render\n        }\n        render();\n    }\n})\nfunction render() {\n    gen((x0, y0) => {\n        // Map pixel space to [-2, 2]x[-2, 2] space\n        let x = -2 + 4 * x0 / width, y = -2 + 4 * y0 / width + 2 * (width - height) / width;\n        for (let i = 0; i < iterations; i++) {\n            // Return when iteration diverges far enough from origin\n            if (x * x + y * y > 4) {\n                return 255 * Math.sqrt(i / iterations);\n            }\n            // Compute next step\n            const newx = x * x - y * y + re;\n            y = 2 * x * y + im;\n            x = newx;\n        }\n        return 0;\n    }, size, size);\n}\n\n//> Drag your mouse around on the canvas to change the fractal parameters",
  "resizing": "// Some random content\ngen((x, y) => [255 * x / 2048, 255 * y / 2048, ((x % 200) < 100) === ((y % 200) < 100) ? 255 : 0], 2048, 2048)\ncopyTo(0);\n\n// Scale to some absolute size\nresize(1920, 1080);\ncopyTo(1);\n\n// Scale relatively\nrescale(0.5);\ncopyTo(2);\n\n// Crop to to left corner\ncrop(600, 300);\ncopyTo(3);\n\n// Crop to right center\ncrop(200, 200, 1, 0.5);",
  "filters": "// We start with some random generator to have something to work with\ngen((x, y) => [x & y, x | y, x ^ y], 512, 512);\ncopyTo(0);\n\n// Invert red\nfilterR(v => 255-v);\ncopyTo(1);\n\n// Flip around green\nfilterG(v => Math.abs(255 - 2 * v));\ncopyTo(2);\n\n// Adjust alpha\nfilter(c => { c[3] = 255 - Math.max(c[0], c[1], c[2]) + Math.min(c[0], c[1], c[2]); return c })",
  "slotUsage": "copy(); // source -> target\nfilter(c => [255-c[0], c[1], c[2], c[3]]); // invert red\ncopyTo(1); // target -> slot 1\nuse(1); // work on slot 1\nfilter(c => [c[2], c[0], c[1], c[3]]); // flip channels\nuse(); // work on target",
  "canvasAnimation": "resize(1280, 720);\nsetFrameHandler(frameContext => {\n    const { fps, frame, time } = frameContext;\n    // Draw a moving circle\n    context.fillStyle = 'black';\n    context.fillRect(0, 0, width, height);\n    context.fillStyle = 'red';\n    context.beginPath();\n    const t = time * Math.PI;\n    const x = width * (0.5 + 0.3 * Math.sin(t));\n    const y = height * (0.5 - 0.3 * Math.cos(t));\n    context.arc(x, y, 50, 0, Math.PI * 2);\n    context.fill();\n\n    // Draw some text\n    context.fillStyle = 'white';\n    context.font = '36px Arial';\n    context.fillText(`FPS: ${fps}`, 10, 40);\n    context.fillText(`Frame: ${frame}`, 10, 80);\n    context.fillText(`Time: ${time.toFixed(2)}s`, 10, 120);\n});",
  "canvasInteraction": "resize(1280, 720);\nsetFrameHandler(frameContext => {\n    const { mouse, keysDown } = frameContext;\n    // Draw a circle at the mouse position\n    context.fillStyle = 'black';\n    context.fillRect(0, 0, width, height);\n    context.fillStyle = 'red';\n    context.beginPath();\n    context.arc(mouse.x, mouse.y, 50, 0, Math.PI * 2);\n    context.fill();\n\n    // Draw some text\n    context.fillStyle = 'white';\n    context.font = '36px Arial';\n    context.fillText(`Mouse: ${mouse.x.toFixed(0)}, ${mouse.y.toFixed(0)}`, 10, 40);\n    context.fillText(`Keys: ${Array.from(keysDown).join(', ')}`, 10, 80);\n});",
  "parameters": "const r = param.toggle('red');\nconst g = param.number('green', 0, 0, 255);\nconst b = param.slider('blue', 0, 0, 255, 1); // Usually, sliders only update at the end of a user interaction\nconst a = param.slider('alpha', 255, 0, 255, 1, true); // setting liveUpdate to true, even dragging the slider will cause rerender of the image\n\nconst seed = param.text('seed', '12345');\nconst button = param.button('Randomize', () => {\n  param.get('seed').set(Math.floor(Math.random() * 100000).toString());\n})\n\nconst color = param.color('color', '#ff0000ff');\nconst spot = param.select('spot', [\"left\", \"middle\", \"right\"], 1);\nconst midFactor = {\n  \"left\": 0.25,\n  \"middle\": 0.5,\n  \"right\": 0.75,\n}[spot];\nconst midx = width * midFactor\n\ngen((x, y) => {\n  if (x >= midx - 20 && x <= midx + 20) {\n    return color;\n  }\n  return [r ? 255 : 0, g, b, a]\n});",
  "tileableCheckPixelmap": "const w = sourceCanvas.width;\nconst h = sourceCanvas.height;\nconst ofx = 1 - param.slider('Offset X', 0.5, 0, 1, 0.001, true);\nconst ofy = 1 - param.slider('Offset Y', 0.5, 0, 1, 0.001, true);\nconst offX = Math.round(ofx * w);\nconst offY = Math.round(ofy * h);\nconst sourceMap = getPixelMap(0);\ngen((x, y) => {\n    const sx = (x + offX) % w;\n    const sy = (y + offY) % h;\n    return sourceMap.get(sx, sy);\n}, w * 2, h * 2);",
  "tileableCheckNative": "const w = sourceCanvas.width;\nconst h = sourceCanvas.height;\nconst tileableX = param.toggle('Tileable X', true);\nconst tileableY = param.toggle('Tileable Y', true);\nconst zoomOut = param.toggle('Zoom Out', false);\nlet ofx = 0, ofy = 0;\nif (tileableX) {\n    ofx = 1 - param.slider('Offset X', 0.5, 0, 1, 0.001, true);\n}\nif (tileableY) {\n    ofy = 1 - param.slider('Offset Y', 0.5, 0, 1, 0.001, true);\n}\nconst showGrid = param.toggle('Show Grid', false);\nconst offX = Math.round(ofx * w);\nconst offY = Math.round(ofy * h);\nconst sizeFactor = zoomOut ? 2 : 1;\ncanvas.width = w * (tileableX ? sizeFactor : 1);\ncanvas.height = h * (tileableY ? sizeFactor : 1);\nconst tilesX = tileableX ? sizeFactor + 1 : 1;\nconst tilesY = tileableY ? sizeFactor + 1 : 1;\n// Images\nfor (let x = 0; x < tilesX; x++) {\n    const imgx = x * w - offX;\n    for (let y = 0; y < tilesY; y++) {\n        const imgy = y * h - offY;\n        context.drawImage(sourceCanvas, imgx, imgy);\n    }\n}\n// Grid lines\nif (showGrid) {\n    context.fillStyle = 'green';\n    const lineWidth = canvas.width / 200;\n    for (let x = 0; x < tilesX; x++) {\n        const imgx = x * w - offX;\n        for (let y = 0; y < tilesY; y++) {\n            const imgy = y * h - offY;\n            // Right border\n            context.fillRect(imgx + w - lineWidth / 2, imgy, lineWidth, h);\n            // Bottom border\n            context.fillRect(imgx, imgy + h - lineWidth / 2, w, lineWidth);\n        }\n    }\n}\n//> If you want to check whether some image of yours is tileable, just drop it in here to check.\n//> Preview shows the image placed next to each other in x and y dimension.\n//> Use the parameters on the right to customize the preview.",
  "whiteCorrection": "copy();\nconst white = param.color('white', '#ffffff');\nconst black = param.color('black', '#000000');\nconst whiteScale = param.slider('white correction', 0, 0, 1, 0.001);\nconst blackScale = param.slider('black correction', 0, 0, 1, 0.001);\nconst dr = white[0] - black[0];\nconst dg = white[1] - black[1];\nconst db = white[2] - black[2];\nconst br = black[0] + dr * blackScale;\nconst bg = black[1] + dg * blackScale;\nconst bb = black[2] + db * blackScale;\nconst wr = white[0] - dr * whiteScale;\nconst wg = white[1] - dg * whiteScale;\nconst wb = white[2] - db * whiteScale;\nconst rFactor = 255 / (wr - br);\nconst gFactor = 255 / (wg - bg);\nconst bFactor = 255 / (wb - bb);\nfilter(c => {\n    // Apply white correction\n    c[0] = (c[0] - br) * rFactor;\n    c[1] = (c[1] - bg) * gFactor;\n    c[2] = (c[2] - bb) * bFactor;\n    return c;\n});\n//> This tool is useful for correcting e.g. photographs of paper write-ups or whiteboard sketches.\n//> Ideally proceed as follows:\n//> 1. Load the image you want to edit by dropping it onto the page.\n//> 2. Use the \"white\" and \"black\" color pickers to select the darkest color that shall be white, and the brightest color that shall be black.\n//> 3. If the adjustment is insufficient, increase the correction sliders until you like the result.",
  "combineIntoOne": "const sources = [];\n        if (param.toggle('Include source', true)) {\n            sources.push(sourceCanvas);\n        }\n        let i = 1;\n        while (true) {\n            const img = get(i++);\n            if (!img) { break; }\n            sources.push(img);\n        }\n        const layout = param.select('Layout', ['Vertical', 'Horizontal', 'Freeform']);\n        const vertical = layout === 'Vertical';\n        const horizontal = layout === 'Horizontal';\n        const freeform = layout === 'Freeform';\n        const sorting = param.select('Sort By', ['Auto', 'None', 'Width', 'Height']);\n        if (sorting === 'Width') {\n            sources.sort((a, b) => (b.naturalWidth || b.width) - (a.naturalWidth || a.width));\n        } else if (sorting === 'Height') {\n            sources.sort((a, b) => (b.naturalHeight || b.height) - (a.naturalHeight || a.height));\n        }\n        if (param.toggle('Invert Order', false)) {\n            sources.reverse();\n        }\n        if (freeform) {\n            // Freeform layout\n            const attempts = param.number('Attempts', 20, 1, 100);\n            let bestRects = [];\n            let bestSize = Infinity;\n            let bestW = 0, bestH = 0;\n            for (let attempt = 0; attempt < attempts; attempt++) {\n                const rects = [{x1:-1000, y1:-1000, x2:1000000, y2:0}, {x1:-1000, y1:-1000, x2:0, y2:1000000}];\n                let maxW = 0, maxH = 0;\n                if (sorting === 'Auto') {\n                    // Random order\n                    sources.sort(() => Math.random() - 0.5);\n                }\n                const checkCollision = (x, y, w, h) => rects.some(rect => !(x >= rect.x2 || x + w < rect.x1 || y >= rect.y2 || y + h < rect.y1));\n                for (const source of sources) {\n                    const sw = (source.naturalWidth || source.width);\n                    const sh = (source.naturalHeight || source.height);\n                    const maxPos = Math.max(maxW, maxH) + 1;\n                    let x = Math.round(Math.random() * 2 * maxPos);\n                    let y = 2 * maxPos - x;\n                    while (true) {\n                        // Walk diagonally with sliding collision until no further movement is possible\n                        const nx = x - 1, ny = y - 1;\n                        let moved = false;\n                        if (!checkCollision(nx, y, sw, sh)) { x = nx; moved = true; }\n                        if (!checkCollision(x, ny, sw, sh)) { y = ny; moved = true; }\n                        if (!moved) {\n                            // No further movement possible\n                            rects.push({x1: x, y1: y, x2: x + sw, y2: y + sh, img: source});\n                            maxW = Math.max(maxW, x + sw);\n                            maxH = Math.max(maxH, y + sh);\n                            break;\n                        }\n                    }\n                }\n                // Best attempt?\n                const size = maxW * maxH;\n                if (size < bestSize) {\n                    bestSize = size;\n                    bestRects = rects;\n                    bestW = maxW;\n                    bestH = maxH;\n                }\n            }\n            // Place images\n            bestRects.splice(0, 2);\n            canvas.width = bestW;\n            canvas.height = bestH;\n            for (rect of bestRects) {\n                context.drawImage(rect.img, rect.x1, rect.y1);\n            }\n        } else {\n            // Vertical or Horizontal stacking\n            if (vertical) {\n                // Stack vertically\n                const maxW = Math.max(...sources.map(s => s.naturalWidth || s.width));\n                const totalH = sources.reduce((acc, s) => acc + (s.naturalHeight || s.height), 0);\n                canvas.width = maxW;\n                canvas.height = totalH;\n            } else if (horizontal) {\n                // Stack horizontally\n                const totalW = sources.reduce((acc, s) => acc + (s.naturalWidth || s.width), 0);\n                const maxH = Math.max(...sources.map(s => s.naturalHeight || s.height));\n                canvas.width = totalW;\n                canvas.height = maxH;\n            }\n            let x = 0, y = 0;\n            for (const source of sources) {\n                const w = (source).naturalWidth || source.width;\n                const h = (source).naturalHeight || source.height;\n                context.drawImage(source, x, y);\n                if (vertical) {\n                    y += h;\n                } else {\n                    x += w;\n                }\n            }\n        }\n        //> How to use this tool:\n        //> 1. Drag your desired images into the slots at the top (and optionally the Source panel on the left)\n        //> 2. Select a Layout style in the menu on the right.\n        //> 3. All other options are pretty much optional and usually not needed.\n        //> Note: \"Freeform\" means that images are placed as compactly as possible in 2D space. Randomness is involved here. If you increase the attempts value, it may take longer, but has a better chance of finding a good packing order."
}